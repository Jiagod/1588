diff -Naur linux-5.12.4_old/drivers/ptp/ptp_clockmatrix.c linux-5.12.4_new/drivers/ptp/ptp_clockmatrix.c
--- linux-5.12.4_old/drivers/ptp/ptp_clockmatrix.c	2021-06-24 05:47:12.060187460 -0400
+++ linux-5.12.4_new/drivers/ptp/ptp_clockmatrix.c	2021-06-24 05:48:00.000000000 -0400
@@ -2189,7 +2189,140 @@
 	idtcm->channel[2].output_mask = DEFAULT_OUTPUT_MASK_PLL2;
 	idtcm->channel[3].output_mask = DEFAULT_OUTPUT_MASK_PLL3;
 }
-
+#if 1//chiahsin
+static ssize_t setmr_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	int err = 0;
+	u8 *buff = NULL;
+	struct idtcm *idtcm = i2c_get_clientdata(to_i2c_client(dev));
+	unsigned long module = 0;
+	unsigned long regaddr = 0;
+	unsigned long length = 0;
+	unsigned long tmpInput = 0;
+	char* const delim = " ";
+	char tmp[16] = {0};
+	char *token = NULL;
+	char *cur = (char *)buf;
+	int i = 0;
+	int j = 0;
+
+	while ((token = strsep(&cur, delim))) {
+		memset(tmp, 0, sizeof(tmp));
+		if(0 == i){
+			strcpy(tmp, token);
+			if(kstrtoul(tmp, 0, &module)){
+				return -EINVAL;
+			}
+		} else if( 1 == i) {
+			strcpy(tmp, token);
+			if(kstrtoul(tmp, 0, &regaddr)){
+				return -EINVAL;
+			}
+		} else if(2 == i) {
+			strcpy(tmp, token);
+			if (kstrtoul(tmp, 0, &length)){
+				return -EINVAL;
+			}
+			buff = kzalloc(sizeof(u8)*length, GFP_KERNEL);
+			if (!buff){
+				return -ENOMEM;
+			}
+		}
+		else {
+			strcpy(tmp, token);
+			if (kstrtoul(tmp,0,&tmpInput)){
+				return -EINVAL;
+			}
+			buff[j] = (u8)tmpInput;
+			j++;
+		}
+		i++;
+	}
+	for (j = 0; j < length; j++){
+		printk("buff[%d] = 0x%02x\n", j, buff[j]);
+	}
+	err = idtcm_write(idtcm, (u16)module, (u16)regaddr, buff, length);
+	if (err){
+		printk("Write Fail\n");
+	} else {
+		printk("Write Done\n");
+	}
+	kfree(buff);
+	return len;
+}
+static ssize_t getmr_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	int err = 0;
+	u8 *buff = NULL;
+	struct idtcm *idtcm = i2c_get_clientdata(to_i2c_client(dev));	
+	unsigned long module = 0;
+	unsigned long regaddr = 0;
+	unsigned long length = 0;
+	char* const delim = " ";
+	char tmp[16] = {0};
+	char *token = NULL;
+	char *cur = (char *)buf;
+	int i = 0;
+	while ((token = strsep(&cur, delim))) {
+		memset(tmp, 0, sizeof(tmp));
+		if(0 == i) {
+			strcpy(tmp, token);
+			if (kstrtoul(tmp, 0, &module)){
+				return -EINVAL;
+			}
+		} else if(1 == i) {
+			strcpy(tmp, token);
+			if (kstrtoul(tmp, 0, &regaddr)){
+				return -EINVAL;
+			}
+		} else if(2 == i) {
+			strcpy(tmp, token);
+			if (kstrtoul(tmp, 0, &length)){
+				return -EINVAL;
+			}
+		}
+		i++;
+	}
+	buff = kzalloc(sizeof(u8)*length, GFP_KERNEL);
+	if (!buff){
+		return -ENOMEM;
+	}
+	err = idtcm_read(idtcm, (u16)module, (u16)regaddr, buff, length);
+	if (err){
+		printk("Read Fail\n");
+	} else {
+		for( i =0; i<length; i++) {
+			printk("[%d] = 0x%02x ", i, buff[i]);
+		}
+		printk("\n");		
+		printk("Read Done\n");	
+	}
+	kfree(buff);
+	return len;
+}
+static DEVICE_ATTR_WO(getmr);
+static DEVICE_ATTR_WO(setmr);
+static struct attribute *idtcm_8a34_attributes[] = {
+	&dev_attr_getmr.attr,
+	&dev_attr_setmr.attr,	
+	NULL,
+};
+static const struct attribute_group idtcm_8a34_group = {
+	.attrs = idtcm_8a34_attributes,
+};
+int idtcm_8a34_register_sysfs(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int ret = 0;
+	ret = sysfs_create_group(&dev->kobj, &idtcm_8a34_group);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(idtcm_8a34_register_sysfs);
+#endif
 static int idtcm_probe(struct i2c_client *client,
 		       const struct i2c_device_id *id)
 {
@@ -2213,6 +2346,9 @@
 
 	mutex_init(&idtcm->reg_lock);
 	mutex_lock(&idtcm->reg_lock);
+#if 1 //chiahsin
+	idtcm_8a34_register_sysfs(client);
+#endif
 
 	idtcm_set_version_info(idtcm);
 
